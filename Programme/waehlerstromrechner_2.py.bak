import csv, numpy, prettytable, time, pickle
import scipy.optimize

class constraint:
    """The constraint class which is used for the generation of constraints in the calculator class"""
    def __init__ ( self, index1, index2 ):
        self.index1 = index1
        self.index2 = index2
        
    def function ( self, x ):
        return sum( x[self.index1:self.index2] ) - 1

class calculator:
    """The class which estimates the transfer matrix with given party n0ames ( both first and second election ) and input to get the elctoral results"""
    def __init__ ( self, parties1, parties2, input, options={"maxiter":100} ):
        self.parties1 = parties1
        self.parties2 = parties2
        self.options  = options
        
        ## (1) Receiving input
        
        try:
            self.data_input = self.extract(input)
        except:
            self.data_input = input
                
        ## (2) Creating data
        
        self.data_output = self.optimize( options )
        
    def extract ( self, input ):
        data = []
        for I in input.units:
            data.append( [I.votes2, I.votes1] )
        return data
        
    def gen_cons ( self ):
        """The function that generates the constraints"""
        self.cons = ()
        self.objects = []
    
        for I in range(len(self.parties1)):
            self.objects.append(constraint(len(self.parties2)*I, len(self.parties2)*(I+1)))
            self.cons += tuple ( [ {"type":"eq", "fun":self.objects[-1].function } ] )
     
    def chi_sprengel ( self, T, E, Eprime ):
        """The function that calculates the chi square for one electoral unit"""
        x = (numpy.dot(Eprime, T ) - E)
        return numpy.dot(x,x.T)
    
    def chi_sum ( self, T ):
        """The function that sums up the chi square error from the electoral units"""
        chi_sum = 0
        T = [ T[len(self.parties2)*i:len(self.parties2)*(i+1) ] for i in range( len( self.parties1 )) ]
        
        for I in self.data_input:
            chi_sum += self.chi_sprengel( T, numpy.matrix(I[0].values()), numpy.matrix(I[1].values()))
        print chi_sum
        return numpy.array(chi_sum)[0][0] / 10000
                
    def optimize ( self, options ):
        """The function that finds the minimal chi square error"""
        self.gen_cons()
        m = numpy.ones( (len(self.parties1), len(self.parties2)) ) / float(len(self.parties2))
        
        result = scipy.optimize.minimize( self.chi_sum, m, method="SLSQP", options = options, constraints = self.cons, bounds = [(0,1)]*len(self.parties1)*len(self.parties2) )
        print result
        return result.x